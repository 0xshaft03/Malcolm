######################## # parsing of logs/metrics specific to the operation of
#                          Malcolm and Hedgehog Linux itself (i.e., not captured
#                          network traffic metadata, but operational metadata)
#
# Copyright (c) 2022 Battelle Energy Alliance, LLC.  All rights reserved.
#######################

filter {

  if (![host][name]) and ([agent][hostname]) {
    mutate { id => "mutate_beats_add_field_host_name_agent_hostname"
             add_field => { "[host][name]" => "%{[agent][hostname]}" } }
  }

  if ([agent][type] == "filebeat") and ([event][module] == "nginx") {
    #############################################################################################################################
    # nginx access and error logs

    # parse log fields
    if ([event][dataset] == "nginx.access") {
      grok {
        id => "grok_beat_nginx_access"
        patterns_dir => "/usr/share/logstash/malcolm-patterns"
        match => { "[event][original]" => "%{NGINX_ACCESS}" }
        # remove_tag => ["_grokparsefailure"]
      }
    }
    if ([event][dataset] == "nginx.error") {
      grok {
        id => "grok_beat_nginx_error"
        patterns_dir => "/usr/share/logstash/malcolm-patterns"
        match => { "[event][original]" => "%{NGINX_ERROR}" }
        # remove_tag => ["_grokparsefailure"]
      }
    }

    # save nginx log timestamp over @timestamp
    if ([timestamp]) {
      date {
        id => "date_beats_nginx_timestamp"
        match => [ "[timestamp]", "dd/MMM/yyyy:HH:mm:ss Z", "yyyy/MM/dd HH:mm:ss" ]
        target => "[@timestamp]"
        remove_field => [ "[timestamp]" ]
      }
    }

    # set agent.type to "nginx"
    mutate { id => "mutate_replace_agent_type_beats_filebeat_nginx"
             replace => { "[agent][type]" => "nginx" } }

  } else if ([agent][type] == "metricbeat") {
    #############################################################################################################################
    # metricbeat statistics (todo: soon to be replaced by fluentbit)

    if (![event][hash]) {
      fingerprint {
        id => "fingerprint_malcolm_beats_metricbeat"
        source => [ "[host][name]",
                    "[event][module]",
                    "[event][dataset]",
                    "[metricset][name]",
                    "[metricset][period]",
                    "[process][pid]",
                    "[@timestamp]" ]
        concatenate_sources => true
        # uses event.hash
        ecs_compatibility => "v8"
        method => "MURMUR3_128"
        base64encode => true
      }
    }

  } else if ("_malcolm_heatbeat" in [tags]) {
    #############################################################################################################################
    # sensor temperature statistics (todo: investigate use of "sensors" to see if fluentbit's "therm" module is better or not)

    if (![event][hash]) {
      fingerprint {
        id => "fingerprint_malcolm_beats_heatbeat"
        source => [ "[host][name]",
                    "[heatbeat][sensors][adapter]",
                    "[heatbeat][sensors][class]",
                    "[heatbeat][sensors][label]",
                    "[heatbeat][sensors][name]",
                    "[heatbeat][sensors][units]",
                    "[heatbeat][sensors][value]",
                    "[@timestamp]" ]
        concatenate_sources => true
        # uses event.hash
        ecs_compatibility => "v8"
        method => "MURMUR3_128"
        base64encode => true
      }
    }

  } else if ("_malcolm_miscbeat" in [tags]) {
    #############################################################################################################################
    # misc. sensor metrics and logs from fluentbit received by protologbeat TCP

    # set event.module to whatever we set "module" to when running fluentbit
    if ([miscbeat][module]) {
      mutate { id => "mutate_replace_event_module_miscbeat_module"
               replace => { "[event][module]" => "%{[miscbeat][module]}" }
               remove_field => [ "[miscbeat][module]" ] }
    }

    # convert fluentbit's date field and save it to @timestamp
    if ([miscbeat][date]) {
      date {
        id => "date_beats_miscbeat_date"
        match => [ "[miscbeat][date]", "UNIX" ]
        target => "[@timestamp]"
        remove_field => [ "[miscbeat][date]" ]
      }
    }

    if ([miscbeat][auditlog]) {
      #-------------------------------------------------
      # fluentbit tail of /var/log/audit/audit.log
      # https://man7.org/linux/man-pages/man5/auditd.conf.5.html

      ruby {
        id => "ruby_miscbeat_auditlog_remove_empty_values"
        path => "/usr/share/logstash/malcolm-ruby/compact_event.rb"
      }

      if ([miscbeat][auditlog][grantors]) {
        mutate { id => "mutate_split_miscbeat_auditlog_grantors"
                 split => { "[miscbeat][auditlog][grantors]" => "," } }
      }

      if (![miscbeat][auditlog][success]) and
         ([miscbeat][auditlog][res] =~ /^success'?$/) {
        mutate { id => "mutate_miscbeat_auditlog_res_success"
                 add_field => { "[miscbeat][auditlog][success]" => "yes" }
                 remove_field => [ "[miscbeat][auditlog][res]" ] }
      }

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_auditlog"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][auditlog][ses]",
                      "[miscbeat][auditlog][type]",
                      "[miscbeat][auditlog][SYSCALL]",
                      "[miscbeat][auditlog][acct]",
                      "[miscbeat][auditlog][UID]",
                      "[miscbeat][auditlog][exe]",
                      "[miscbeat][auditlog][msg]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][auditlog])

    if ([miscbeat][kmsg]) {
      #-------------------------------------------------
      # kmsg - https://docs.fluentbit.io/manual/pipeline/inputs/kernel-logs
      mutate { id => "mutate_rename_miscbeat_kmsg"
               rename => { "[miscbeat][kmsg][msg]" => "[event][original]" } }

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_kmsg"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][kmsg][sequence]",
                      "[miscbeat][kmsg][priority]",
                      "[event][original]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][kmsg])

    if ([miscbeat][syslog]) {
      #-------------------------------------------------
      # syslog - https://docs.fluentbit.io/manual/pipeline/inputs/syslog

      # time gets parsed into the miscbeat.date field, this is redundant
      mutate { id => "mutate_miscbeat_remove_syslog_time"
               remove_field => [ "[miscbeat][syslog][time]" ] }

      # rename syslog fields according to ECS
      # https://www.elastic.co/guide/en/ecs/current/ecs-log.html#field-log-syslog
      mutate { id => "mutate_rename_miscbeat_syslog"
               rename => { "[miscbeat][syslog][ident]" => "[log][syslog][appname]" }
               rename => { "[miscbeat][syslog][pid]" => "[log][syslog][procid]" }
               rename => { "[miscbeat][syslog][pri]" => "[log][syslog][priority]" }
               rename => { "[miscbeat][syslog][message]" => "[event][original]" }
               rename => { "[miscbeat][syslog][host]" => "[log][syslog][hostname]" }
      }

      # convert syslog "priority" number to "severity" and "facility" and map to human-readable names
      if ([log][syslog][priority]) {
        ruby {
          id => "ruby_log_syslog_priority_convert"
          code => "
            if pri = event.get('[log][syslog][priority]').to_i then
              event.set('[log][syslog][severity][code]', pri % 8)
              event.set('[log][syslog][facility][code]', pri / 8)
            end"
        }
        if ([log][syslog][severity][code]) {
          translate {
            id => "translate_sensor_syslog_severity_code"
            source => "[log][syslog][severity][code]"
            target => "[log][syslog][severity][name]"
            dictionary_path => "/etc/syslog_severity_levels.yaml"
          }
        }
        if ([log][syslog][facility][code]) {
          translate {
            id => "translate_sensor_syslog_facility_code"
            source => "[log][syslog][facility][code]"
            target => "[log][syslog][facility][name]"
            dictionary_path => "/etc/syslog_facility_codes.yaml"
          }
        }
      }

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_syslog"
          source => [ "[host][name]",
                      "[event][module]",
                      "[log][syslog][severity][code]",
                      "[log][syslog][facility][code]",
                      "[log][syslog][appname]",
                      "[event][original]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][syslog])

  } # event type (nginx, heatbeat, metricbeat, miscbeat, etc)

}