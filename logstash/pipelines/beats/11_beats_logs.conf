filter {

  if ([agent][type] == "filebeat") and ([event][module] == "nginx") {

    # event.hash will be done based on event.original in 98_finalize.conf

    if ([event][dataset] == "nginx.access") {
      grok {
        id => "grok_beat_nginx_access"
        patterns_dir => "/usr/share/logstash/malcolm-patterns"
        match => { "[event][original]" => "%{NGINX_ACCESS}" }
        # remove_tag => ["_grokparsefailure"]
      }
    }
    if ([event][dataset] == "nginx.error") {
      grok {
        id => "grok_beat_nginx_error"
        patterns_dir => "/usr/share/logstash/malcolm-patterns"
        match => { "[event][original]" => "%{NGINX_ERROR}" }
        # remove_tag => ["_grokparsefailure"]
      }
    }

    if ([timestamp]) {
      date {
        id => "date_beats_nginx_timestamp"
        match => [ "[timestamp]", "dd/MMM/yyyy:HH:mm:ss Z", "yyyy/MM/dd HH:mm:ss" ]
        target => "[@timestamp]"
        remove_field => [ "[timestamp]" ]
      }
    }

    mutate { id => "mutate_replace_agent_type_beats_filebeat_nginx"
             replace => { "[agent][type]" => "nginx" } }

  } else if ([agent][type] == "auditbeat") {

    if (![event][hash]) {
      fingerprint {
        id => "fingerprint_malcolm_beats_auditbeat"
        source => [ "[host][name]",
                    "[event][module]",
                    "[event][kind]",
                    "[event][category]",
                    "[event][action]",
                    "[auditd][session]",
                    "[auditd][sequence]",
                    "[process][pid]",
                    "[@timestamp]" ]
        concatenate_sources => true
        # uses event.hash
        ecs_compatibility => "v8"
        method => "MURMUR3_128"
        base64encode => true
      }
    }

  } else if ([agent][type] == "metricbeat") {

    if (![event][hash]) {
      fingerprint {
        id => "fingerprint_malcolm_beats_metricbeat"
        source => [ "[host][name]",
                    "[event][module]",
                    "[event][dataset]",
                    "[metricset][name]",
                    "[metricset][period]",
                    "[process][pid]",
                    "[@timestamp]" ]
        concatenate_sources => true
        # uses event.hash
        ecs_compatibility => "v8"
        method => "MURMUR3_128"
        base64encode => true
      }
    }

  } else if ("_malcolm_heatbeat" in [tags]) {

    if (![event][hash]) {
      fingerprint {
        id => "fingerprint_malcolm_beats_heatbeat"
        source => [ "[host][name]",
                    "[heatbeat][sensors][adapter]",
                    "[heatbeat][sensors][class]",
                    "[heatbeat][sensors][label]",
                    "[heatbeat][sensors][name]",
                    "[heatbeat][sensors][units]",
                    "[heatbeat][sensors][value]",
                    "[@timestamp]" ]
        concatenate_sources => true
        # uses event.hash
        ecs_compatibility => "v8"
        method => "MURMUR3_128"
        base64encode => true
      }
    }

  } else if ("_malcolm_miscbeat" in [tags]) {

    if ([miscbeat][module]) {
      mutate { id => "mutate_replace_event_module_miscbeat_module"
               replace => { "[event][module]" => "%{[miscbeat][module]}" }
               remove_field => [ "[miscbeat][module]" ] }
    }

    if ([miscbeat][date]) {
      date {
        id => "date_beats_miscbeat_date"
        match => [ "[miscbeat][date]", "UNIX" ]
        target => "[@timestamp]"
        remove_field => [ "[miscbeat][date]" ]
      }
    }

    if ([event][module] == "syslog") {
      # time gets parsed into the miscbeat.date field, this is redundant
      mutate { id => "mutate_miscbeat_remove_syslog_time"
               remove_field => [ "[miscbeat][time]" ] }

      # rename fields according to ECS
      mutate { id => "mutate_rename_miscbeat_syslog"
               rename => { "[miscbeat][ident]" => "[log][syslog][appname]" }
               rename => { "[miscbeat][pid]" => "[log][syslog][procid]" }
               rename => { "[miscbeat][pri]" => "[log][syslog][priority]" }
               rename => { "[miscbeat][message]" => "[event][original]" }
               rename => { "[miscbeat][host]" => "[log][syslog][hostname]" }
      }

      if ([log][syslog][priority]) {
        ruby {
          id => "ruby_log_syslog_priority_convert"
          code => "
            if pri = event.get('[log][syslog][priority]').to_i then
              event.set('[log][syslog][severity][code]', pri % 8)
              event.set('[log][syslog][facility][code]', pri / 8)
            end"
        }
        if ([log][syslog][severity][code]) {
          translate {
            id => "translate_sensor_syslog_severity_code"
            source => "[log][syslog][severity][code]"
            target => "[log][syslog][severity][name]"
            dictionary_path => "/etc/syslog_severity_levels.yaml"
          }
        }
        if ([log][syslog][facility][code]) {
          translate {
            id => "translate_sensor_syslog_facility_code"
            source => "[log][syslog][facility][code]"
            target => "[log][syslog][facility][name]"
            dictionary_path => "/etc/syslog_facility_codes.yaml"
          }
        }
      }

    }

    if (![event][hash]) {
      fingerprint {
        id => "fingerprint_malcolm_beats_miscbeat"
        source => [ "[host][name]",
                    "[agent][type]",
                    "[event][module]",
                    "[@timestamp]" ]
        concatenate_sources => true
        # uses event.hash
        ecs_compatibility => "v8"
        method => "MURMUR3_128"
        base64encode => true
      }
    }

  } # event.module (nginx/auditd/etc.)

}