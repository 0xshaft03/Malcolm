filter {

    # If message looks like json, try to parse it as such. Otherwise, drop it like it's hot.
    if [message] =~ /^{.*}$/ {

        # parse the json message from eve*.json
        json { id => "json_parse_suricata"
               source => "message"
               target => "suricata" }

        # drop fields we don't need
        mutate { id => "mutate_remove_field_suricata_message_and_stats"
                 remove_field => [ "[suricata][stats]" ] }

        # tags may have been specified, like: eve-123456789-1-(tagA,tagB,tagC).json, extract the tags
        ruby {
          id => "ruby_suricata_tags_extract"
          code => "
            if fileParts = event.get('[log][file][path]').split('/').last.match(/eve-\d+-\d+-(?:\((.*)\))?\.json/i) then
              tags = fileParts.captures[0]
              unless tags.nil?
                filenameTags = tags.split(',')
                filenameTags.delete_if{|v| ((v == nil) or (v == '') or (v !~ /\D/) or (v =~ /\A\s*(eve|pcap|dmp|log|bro|zeek|suricata|tcpdump|netsniff|autozeek|autosuricata)s?\s*\z/i))}
                event.set('[@metadata][suricata_log_tags]', filenameTags.uniq) unless (filenameTags.length == 0)
              end
            end"
        }
        if ([@metadata][suricata_log_tags]) { mutate { id => "mutate_merge_suricata_log_tags"
                                                       merge => { "[tags]" => "[@metadata][suricata_log_tags]" } } }

        if (![event][provider]) { mutate { id => "mutate_add_field_event_provider_suricata"
                                           add_field => { "[event][provider]" => "suricata" } } }

        if ([suricata][flow_id]) {
          # flow ID is sort of equivalent to zeek's conn UID

          # set suricata flow_id as "rootId"
          if (![rootId]) { mutate { id => "mutate_add_field_suricata_flow_id"
                                    add_field => { "[rootId]" => "%{[suricata][flow_id]}" } } }

          # ECS - suricata.flow_id -> event.id
          mutate { id => "mutate_add_field_ecs_suricata_event_id"
                   merge => { "[event][id]" => "[suricata][flow_id]" } }
        }

        # take care of log timestamps in the formats all the different tools want them (phew!)
        # @timestamp - date type
        # suricata.timestamp - ISO8601-formatted string
        # suricata.flow.start - ISO8601-formatted string
        # suricata.flow.end - ISO8601-formatted string
        # timestamp - epoch millseconds
        # firstPacket - epoch millseconds
        # lastPacket - epoch millseconds
        # length - milliseconds
        # event.duration - epoch nanoseconds

        if (![suricata][timestamp]) {
          ruby {
            id => "ruby_suricata_timestamp_now"
            init => "require 'time'"
            code => "event.set('[suricata][timestamp]', Time.now.iso8601)"
          }
          mutate { id => "tag_suricata_empty_timestamp_set"
                   add_tag => [ "_missing_timestamp" ] }
        }

        ruby {
          id => "ruby_suricata_timestamp_calc"
          init => "require 'time'; require 'date';"
          code => "
            timeStampMs = (1000*DateTime.parse(event.get('[suricata][timestamp]')).to_time.to_f).round(0)
            startTimeStr = event.get('[suricata][flow][start]')
            endTimeStr = event.get('[suricata][flow][end]')
            startTimeMs = startTimeStr.nil? ? timeStampMs : (1000*DateTime.parse(startTimeStr).to_time.to_f).round(0)
            endTimeMs = endTimeStr.nil? ? timeStampMs : (1000*DateTime.parse(endTimeStr).to_time.to_f).round(0)
            durationMs = (endTimeMs > startTimeMs) ? endTimeMs-startTimeMs : 0
            event.set('[timestamp]', timeStampMs)
            event.set('[firstPacket]', startTimeMs)
            event.set('[lastPacket]', endTimeMs)
            event.set('[length]', durationMs)
            event.set('[event][duration]', 1000000*durationMs)
          "
        }

        #Renaming the global fields of every Suricata event type
        mutate { id => "mutate_suricata_rename_global_fields"
                 rename => { "[suricata][app_proto]" => "[network][protocol]" }
                 rename => { "[suricata][community_id]" => "[network][community_id]" }
                 rename => { "[suricata][dest_ip]" => "[destination][ip]" }
                 rename => { "[suricata][dest_port]" => "[destination][port]" }
                 rename => { "[suricata][src_ip]" => "[source][ip]" }
                 rename => { "[suricata][src_port]" => "[source][port]" }
                 rename => { "[suricata][proto]" => "[ipProtocol]" }
                 rename => { "[suricata][event_type]" => "[event][dataset]" }
        }

        # transport protocol (e.g., udp, tcp, etc.)
        if ([ipProtocol]) {
          translate {
            id => "translate_suricata_proto"
            source => "[ipProtocol]"
            target => "[network][transport]"
            dictionary_path => "/etc/ip_protocol_number_to_name.yaml"
          }
          # ECS - ipProtocol -> network.iana_number
          mutate { id => "mutate_add_field_suricata_ecs_network_iana_number"
                   add_field => { "[network][iana_number]" => "%{[ipProtocol]}" } }
        }
        if ([network][transport]) {
          mutate { id => "mutate_merge_suricata_proto"
                   merge => { "[protocol]" => "[network][transport]" } }
        }


        ###
        #
        # This section will be for renaming specific event type field names
        # that are able to be mapped to the Elastic Common Schema (ECS)
        #
        ###

        #Specific Alert renaming
        mutate {
                id => "mutate_rename_suricata_alert_severity"
                rename => { "[suricata][alert][severity]" => "[event][severity]" }
        }

        #Specific http renaming
        mutate {
                id => "mutate_rename_suricata_http"
                rename => { "[suricata][http][protocol]" => "[http][version]"}
                rename => { "[suricata][http][status]" => "[http][response][status_code]"}
        }

        #Specific dns renaming
        mutate {
                id => "mutate_rename_suricata_dns"
                rename => { "[suricata][dns][id]" => "[dns][id]"}
                rename => { "[suricata][dns][type]" => "[dns][type]"}
                rename => { "[suricata][dns][rcode]" => "[dns][response_code]"}
        }

        #Specific tls renaming
        mutate { id => "mutate_remove_field_suricata_ja3_strings"
                 remove_field => [ "[suricata][tls][ja3][string]",
                                   "[suricata][tls][ja3s][string]" ] }

        mutate {
                 id => "mutate_rename_suricata_tls"
                 rename => { "[suricata][tls][version]" => "[tls][version]"}
                 rename => { "[suricata][tls][ja3s][hash]" => "[tls][server][ja3s]"}
                 rename => { "[suricata][tls][ja3][hash]" => "[tls][client][ja3]"}
         }

         if ([tls][client][ja3] == "") {
                 mutate {
                         id => "mutate_remove_field_tls_client_ja3_suricata"
                         remove_field => [ "[tls][client][ja3]" ]
                 }
         }

         if ([tls][server][ja3s] == "") {
                 mutate {
                         id => "mutate_remove_field_tls_server_ja3s_suricata"
                         remove_field => [ "[tls][server][ja3s]" ]
                 }
         }

        #Specific fileinfo renaming
        mutate {
                id => "mutate_rename_suricata_fileinfo"
                rename => { "[suricata][fileinfo][size]" => "[file][size]"}
                rename => { "[suricata][fileinfo][sid]" => "[file][uid]"}
                rename => { "[suricata][fileinfo][filename]" => "[file][path]"}
        }

        if ([suricata][pcap_filename]) {
          # trim path portion of suricata.pcap_filename
          mutate { id => "mutate_gsub_suricata_pcap_filename_path"
                   gsub => [ "[suricata][pcap_filename]", "^.*/", "" ] }
        }

        # ECS - event.kind based on event.dataset (https://www.elastic.co/guide/en/ecs/current/ecs-allowed-values-event-kind.html)
        if ([event][dataset] == "alert") {
          mutate { id => "mutate_add_field_suricata_ecs_event_kind_alert"
                   add_field => { "[event][kind]" => "alert" } }
        } else {
          mutate { id => "mutate_add_field_suricata_ecs_event_kind_event"
                   add_field => { "[event][kind]" => "event" } }
        }

        # create a repeatable fingerprint for document ID
        fingerprint {
          id => "fingerprint_suricata_event_hash_flow_id"
          source => [ "[event][provider]",
                      "[event][dataset]",
                      "[suricata][timestamp]",
                      "[network][community_id]",
                      "[suricata][flow_id]",
                      "[log][offset]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v1"
          method => "MURMUR3_128"
          base64encode => true
        }

    } else {
        drop { id => "drop_suricata_invalid_logs" }
    }

}