filter {

    # fields TODO:
    # for ones with a *lot* of fields I'm just going to hand-wave a bit and tackle it when i get there
    #
    # suricata.alert.category - "Potentially Bad Traffic", "Attempted Administrator Privilege Gain", etc.
    # suricata.alert.metadata.affected_product - something for ECS vulnerability?
    # suricata.alert.metadata.attack_target    - ''
    # suricata.alert.metadata.cve              - ''
    # suricata.alert.metadata.deployment       - ''
    # suricata.alert.metadata.former_category  - tags maybe? or maybe just ignore
    # suricata.alert.metadata.malware_family
    # suricata.alert.metadata.mitre_tactic_id
    # suricata.alert.metadata.mitre_tactic_name
    # suricata.alert.metadata.mitre_technique_id
    # suricata.alert.metadata.mitre_technique_name
    # suricata.alert.metadata.performance_impact
    # suricata.alert.metadata.signature_severity - map to my severity
    # suricata.alert.metadata.tag                - tags maybe
    # suricata.alert.signature                   - normalize with my signatures
    # suricata.alert.signature_id                - ''

    # suricata.dnp3....                          - examine individually and look at exising DNP3 stuff
    # suricata.dns.....                          - examine individually and look at exising DNS stuff
    # suricata.ftp.reply                         - event.result
    # suricata.ftp.dynamic_port                  - tie to another port field that's normalized?
    # suricata.ftp.completion_code               - map to a string result and to event.result
    # suricata.ftp.command                       - event.action
    # suricata.http....                          - examine individually and look at exising HTTP stuff
    # suricata.*icmp_code/*icmp_type             - event.action/event.result? does that make sense
    # suricata.ikev2.payload                     - event.action?
    # suricata.ikev2.version_*                   - network.protocol_version
    # suricata.krb5.cname                        - user? related.user?
    # suricata.krb5.error_code                   - event.result
    # suricata.krb5.failed_request               - not sure, is this the action, or the failure, or the reason for the failure?
    # suricata.krb5.msg_type                     - ''
    # suricata.krb5.realm                        - related.host or something like that?
    # suricata.krb5.sname                        - user? related.user? related.host or something like that?
    # suricata.rdp....                           - examine individually and look at exising RDP stuff
    # suricata.rfb....                           - examine individually and look at exising RFB stuff
    # suricata.sip.code / suricata.sip.reason    - event.result
    # suricata.sip.method                        - event.action
    # suricata.sip.uri                           - related uri?
    # suricata.sip.version                       - network.protocol_version
    # suricata.smb....                           - examine individually and look at exising SMB stuff
    # suricata.smtp.helo                         - related host?
    # suricata.smtp.mail_from                    - related email
    # suricata.smtp.rcpt_to                      - related email
    # suricata.snmp.community                    - password? not really...
    # suricata.snmp.error                        - event.result
    # suricata.snmp.pdu_type                     - event.action or event.result
    # suricata.snmp.trap_address                 - ip type? at least related.ip or related.host?
    # suricata.snmp.trap_type                    - event.action or event.result
    # suricata.snmp.usm                          - related user?
    # suricata.snmp.version                      - network.protocol_version
    # suricata.ssh....                           - examine individually and look at exising SSH stuff
    # suricata.tftp.file                         - normalize with other filenames
    # suricata.tftp.packet                       - event.action?
    # suricata.tls.from_proto                    - normalize with network.protocol?
    # suricata.tls.notafter/notbefore            - date type
    # suricata.tls.sni                           - related domain? freq?
    # suricata.tunnel.dest_ip/dest_port          - normalize into destination?
    # suricata.tunnel.src_ip/src_port            - normalize into source?
    # suricata.tunnel.proto                      - map and normalize


    # other TODO:
    # remove "failed" from protocols?
    # parsing old files?
    #

    #############################################################################################################################
    # If message looks like json, try to parse it as such. Otherwise, drop it like it's hot.
    if [message] =~ /^{.*}$/ {

        # parse the json message from eve*.json
        json { id => "json_parse_suricata"
               source => "message"
               target => "suricata" }

        # drop fields we don't need
        mutate { id => "mutate_remove_field_suricata_message_and_stats"
                 remove_field => [ "[suricata][stats]" ] }

        # tags may have been specified, like: eve-123456789-1-(tagA,tagB,tagC).json, extract the tags
        ruby {
          id => "ruby_suricata_tags_extract"
          code => "
            if fileParts = event.get('[log][file][path]').split('/').last.match(/eve-\d+-\d+-(?:\((.*)\))?\.json/i) then
              tags = fileParts.captures[0]
              unless tags.nil?
                filenameTags = tags.split(',')
                filenameTags.delete_if{|v| ((v == nil) or (v == '') or (v !~ /\D/) or (v =~ /\A\s*(eve|pcap|dmp|log|bro|zeek|suricata|tcpdump|netsniff|autozeek|autosuricata)s?\s*\z/i))}
                event.set('[@metadata][suricata_log_tags]', filenameTags.uniq) unless (filenameTags.length == 0)
              end
            end"
        }
        if ([@metadata][suricata_log_tags]) { mutate { id => "mutate_merge_suricata_log_tags"
                                                       merge => { "[tags]" => "[@metadata][suricata_log_tags]" } } }

        if (![event][provider]) { mutate { id => "mutate_add_field_event_provider_suricata"
                                           add_field => { "[event][provider]" => "suricata" } } }

        if ([suricata][flow_id]) {
          # flow ID is sort of equivalent to zeek's conn UID

          # set suricata flow_id as "rootId"
          if (![rootId]) { mutate { id => "mutate_add_field_suricata_flow_id"
                                    add_field => { "[rootId]" => "%{[suricata][flow_id]}" } } }

          # ECS - suricata.flow_id -> event.id
          mutate { id => "mutate_add_field_ecs_suricata_event_id"
                   merge => { "[event][id]" => "[suricata][flow_id]" } }
        }

        if ([suricata][pcap_filename]) {
          # trim path portion of suricata.pcap_filename
          mutate { id => "mutate_gsub_suricata_pcap_filename_path"
                   gsub => [ "[suricata][pcap_filename]", "^.*/", "" ] }
        }

        # ECS - event.kind based on event_type (https://www.elastic.co/guide/en/ecs/current/ecs-allowed-values-event-kind.html)
        if ([suricata][event_type] == "alert") {
          mutate { id => "mutate_add_field_suricata_ecs_event_kind_alert"
                   add_field => { "[event][kind]" => "alert" } }
        } else {
          mutate { id => "mutate_add_field_suricata_ecs_event_kind_event"
                   add_field => { "[event][kind]" => "event" } }
        }

        #############################################################################################################################
        # take care of log timestamps in the formats all the different tools want them (phew!)
        # @timestamp - date type
        # suricata.timestamp - ISO8601-formatted string
        # suricata.flow.start - ISO8601-formatted string
        # suricata.flow.end - ISO8601-formatted string
        # timestamp - epoch millseconds
        # firstPacket - epoch millseconds
        # lastPacket - epoch millseconds
        # length - milliseconds
        # event.duration - epoch nanoseconds

        if (![suricata][timestamp]) {
          ruby {
            id => "ruby_suricata_timestamp_now"
            init => "require 'time'"
            code => "event.set('[suricata][timestamp]', Time.now.iso8601)"
          }
          mutate { id => "tag_suricata_empty_timestamp_set"
                   add_tag => [ "_missing_timestamp" ] }
        }

        ruby {
          id => "ruby_suricata_timestamp_calc"
          init => "require 'time'; require 'date';"
          code => "
            timeStampMs = (1000*DateTime.parse(event.get('[suricata][timestamp]')).to_time.to_f).round(0)
            startTimeStr = event.get('[suricata][flow][start]')
            endTimeStr = event.get('[suricata][flow][end]')
            ageMs = 1000*event.get('[suricata][flow][age]').to_i
            startTimeMs = startTimeStr.nil? ? timeStampMs : (1000*DateTime.parse(startTimeStr).to_time.to_f).round(0)
            endTimeMs = endTimeStr.nil? ? timeStampMs : (1000*DateTime.parse(endTimeStr).to_time.to_f).round(0)
            durationMs = (ageMs > 0) ? ageMs : ((endTimeMs > startTimeMs) ? endTimeMs-startTimeMs : 0)
            event.set('[timestamp]', timeStampMs)
            event.set('[firstPacket]', startTimeMs)
            event.set('[lastPacket]', endTimeMs)
            event.set('[length]', durationMs)
            event.set('[event][duration]', 1000000*durationMs)
          "
        }

        #############################################################################################################################
        #Renaming the global fields of every Suricata event type
        mutate { id => "mutate_suricata_rename_global_fields"
                 rename => { "[suricata][app_proto]" => "[network][protocol]" }
                 rename => { "[suricata][community_id]" => "[network][community_id]" }
                 rename => { "[suricata][dest_ip]" => "[destination][ip]" }
                 rename => { "[suricata][dest_port]" => "[destination][port]" }
                 rename => { "[suricata][src_ip]" => "[source][ip]" }
                 rename => { "[suricata][src_port]" => "[source][port]" }
                 rename => { "[suricata][proto]" => "[ipProtocol]" }
                 rename => { "[suricata][event_type]" => "[event][dataset]" }
                 rename => { "[suricata][vlan]" => "[network][vlan][id]" }
        }

        #############################################################################################################################
        # network protocol stuff

        # transport protocol (e.g., udp, tcp, etc.)
        if ([ipProtocol]) {
          translate {
            id => "translate_suricata_proto"
            source => "[ipProtocol]"
            target => "[network][transport]"
            dictionary_path => "/etc/ip_protocol_number_to_name.yaml"
          }
          # ECS - ipProtocol -> network.iana_number
          mutate { id => "mutate_add_field_suricata_ecs_network_iana_number"
                   add_field => { "[network][iana_number]" => "%{[ipProtocol]}" } }
        }
        if ([network][transport]) {
          mutate { id => "mutate_merge_suricata_proto"
                   merge => { "[protocol]" => "[network][transport]" } }
        }

        # network (application) protocol
        if ([suricata][app_proto_orig]) {
          mutate { id => "mutate_merge_suricata_app_proto_orig"
                   merge => { "[network][protocol]" => "[suricata][app_proto_orig]" } }
        }
        if ([suricata][app_proto_expected]) {
          mutate { id => "mutate_merge_suricata_app_proto_expected"
                   merge => { "[network][protocol]" => "[suricata][app_proto_expected]" } }
        }
        if ([suricata][app_proto_tc]) {
          mutate { id => "mutate_merge_suricata_app_proto_tc"
                   merge => { "[network][protocol]" => "[suricata][app_proto_tc]" } }
        }
        if ([suricata][app_proto_ts]) {
          mutate { id => "mutate_merge_suricata_app_proto_ts"
                   merge => { "[network][protocol]" => "[suricata][app_proto_ts]" } }
        }
        if ([suricata][anomaly][app_proto]) {
          mutate { id => "mutate_merge_suricata_anomaly_app_proto"
                   merge => { "[network][protocol]" => "[suricata][anomaly][app_proto]" } }
        }

        if (![network][protocol]) {

          if ([suricata][dcerpc]) {
            mutate { id => "mutate_add_field_suricata_dcerpc"
                     add_field => { "[@metadata][suricata_dcerpc]" => "dce_rpc" } }
            mutate { id => "mutate_merge_suricata_dcerpc"
                     merge => { "[network][protocol]" => "[@metadata][suricata_dcerpc]" } }
          }
          if ([suricata][dhcp]) {
            mutate { id => "mutate_add_field_suricata_dhcp"
                     add_field => { "[@metadata][suricata_dhcp]" => "dhcp" } }
            mutate { id => "mutate_merge_suricata_dhcp"
                     merge => { "[network][protocol]" => "[@metadata][suricata_dhcp]" } }
          }
          if ([suricata][dnp3]) {
            mutate { id => "mutate_add_field_suricata_dnp3"
                     add_field => { "[@metadata][suricata_dnp3]" => "dnp3" } }
            mutate { id => "mutate_merge_suricata_dnp3"
                     merge => { "[network][protocol]" => "[@metadata][suricata_dnp3]" } }
          }
          if ([suricata][dns]) {
            mutate { id => "mutate_add_field_suricata_dns"
                     add_field => { "[@metadata][suricata_dns]" => "dns" } }
            mutate { id => "mutate_merge_suricata_dns"
                     merge => { "[network][protocol]" => "[@metadata][suricata_dns]" } }
          }
          if ([suricata][ftp]) {
            mutate { id => "mutate_add_field_suricata_ftp"
                     add_field => { "[@metadata][suricata_ftp]" => "ftp" } }
            mutate { id => "mutate_merge_suricata_ftp"
                     merge => { "[network][protocol]" => "[@metadata][suricata_ftp]" } }
          }
          if ([suricata][http]) {
            mutate { id => "mutate_add_field_suricata_http"
                     add_field => { "[@metadata][suricata_http]" => "http" } }
            mutate { id => "mutate_merge_suricata_http"
                     merge => { "[network][protocol]" => "[@metadata][suricata_http]" } }
          }
          if ([suricata][icmp_code]) or
             ([suricata][icmp_type]) or
             ([suricata][response_icmp_code]) or
             ([suricata][response_icmp_type]) {
            mutate { id => "mutate_add_field_suricata_icmp"
                     add_field => { "[@metadata][suricata_icmp]" => "icmp" } }
            mutate { id => "mutate_merge_suricata_icmp"
                     merge => { "[network][protocol]" => "[@metadata][suricata_icmp]" } }
          }
          if ([suricata][ikev2]) {
            mutate { id => "mutate_add_field_suricata_ikev2"
                     add_field => { "[@metadata][suricata_ikev2]" => "ikev2" } }
            mutate { id => "mutate_merge_suricata_ikev2"
                     merge => { "[network][protocol]" => "[@metadata][suricata_ikev2]" } }
          }
          if ([suricata][krb5]) {
            mutate { id => "mutate_add_field_suricata_krb5"
                     add_field => { "[@metadata][suricata_krb5]" => "krb5" } }
            mutate { id => "mutate_merge_suricata_krb5"
                     merge => { "[network][protocol]" => "[@metadata][suricata_krb5]" } }
          }
          if ([suricata][nfs]) {
            mutate { id => "mutate_add_field_suricata_nfs"
                     add_field => { "[@metadata][suricata_nfs]" => "nfs" } }
            mutate { id => "mutate_merge_suricata_nfs"
                     merge => { "[network][protocol]" => "[@metadata][suricata_nfs]" } }
          }
          if ([suricata][rdp]) {
            mutate { id => "mutate_add_field_suricata_rdp"
                     add_field => { "[@metadata][suricata_rdp]" => "rdp" } }
            mutate { id => "mutate_merge_suricata_rdp"
                     merge => { "[network][protocol]" => "[@metadata][suricata_rdp]" } }
          }
          if ([suricata][rpc]) {
            mutate { id => "mutate_add_field_suricata_rpc"
                     add_field => { "[@metadata][suricata_rpc]" => "rpc" } }
            mutate { id => "mutate_merge_suricata_rpc"
                     merge => { "[network][protocol]" => "[@metadata][suricata_rpc]" } }
          }
          if ([suricata][sip]) {
            mutate { id => "mutate_add_field_suricata_sip"
                     add_field => { "[@metadata][suricata_sip]" => "sip" } }
            mutate { id => "mutate_merge_suricata_sip"
                     merge => { "[network][protocol]" => "[@metadata][suricata_sip]" } }
          }
          if ([suricata][smb]) {
            mutate { id => "mutate_add_field_suricata_smb"
                     add_field => { "[@metadata][suricata_smb]" => "smb" } }
            mutate { id => "mutate_merge_suricata_smb"
                     merge => { "[network][protocol]" => "[@metadata][suricata_smb]" } }
          }
          if ([suricata][smtp]) {
            mutate { id => "mutate_add_field_suricata_smtp"
                     add_field => { "[@metadata][suricata_smtp]" => "smtp" } }
            mutate { id => "mutate_merge_suricata_smtp"
                     merge => { "[network][protocol]" => "[@metadata][suricata_smtp]" } }
          }
          if ([suricata][snmp]) {
            mutate { id => "mutate_add_field_suricata_snmp"
                     add_field => { "[@metadata][suricata_snmp]" => "snmp" } }
            mutate { id => "mutate_merge_suricata_snmp"
                     merge => { "[network][protocol]" => "[@metadata][suricata_snmp]" } }
          }
          if ([suricata][ssh]) {
            mutate { id => "mutate_add_field_suricata_ssh"
                     add_field => { "[@metadata][suricata_ssh]" => "ssh" } }
            mutate { id => "mutate_merge_suricata_ssh"
                     merge => { "[network][protocol]" => "[@metadata][suricata_ssh]" } }
          }
          if ([suricata][tftp]) {
            mutate { id => "mutate_add_field_suricata_tftp"
                     add_field => { "[@metadata][suricata_tftp]" => "tftp" } }
            mutate { id => "mutate_merge_suricata_tftp"
                     merge => { "[network][protocol]" => "[@metadata][suricata_tftp]" } }
          }
          if ([suricata][tls]) {
            mutate { id => "mutate_add_field_suricata_tls"
                     add_field => { "[@metadata][suricata_tls]" => "tls" } }
            mutate { id => "mutate_merge_suricata_tls"
                     merge => { "[network][protocol]" => "[@metadata][suricata_tls]" } }
          }
        }

        #############################################################################################################################
        # protocol-specific

        #############################################################################################################################
        # flow
        # ECS - suricata.bytes_toclient -> server.bytes
        if ([suricata][flow]) {
          if ([suricata][flow][bytes_toclient])  {
            mutate { id => "mutate_add_field_suricata_flow_server_bytes"
                     add_field => { "[server][bytes]" => "%{[suricata][flow][bytes_toclient]}" } }
          }
          if ([suricata][flow][bytes_toserver])  {
            mutate { id => "mutate_add_field_suricata_flow_client_bytes"
                     add_field => { "[client][bytes]" => "%{[suricata][flow][bytes_toserver]}" } }
          }
          if ([suricata][flow][pkts_toclient])  {
            mutate { id => "mutate_add_field_suricata_flow_server_pkts"
                     add_field => { "[server][packets]" => "%{[suricata][flow][pkts_toclient]}" } }
          }
          if ([suricata][flow][pkts_toserver])  {
            mutate { id => "mutate_add_field_suricata_flow_client_pkts"
                     add_field => { "[client][packets]" => "%{[suricata][flow][pkts_toserver]}" } }
          }
          # aggregate total bytes and packets
          ruby {
            id => "ruby_suricata_bytes_and_packets_calc"
            code => "totBytes = event.get('[client][bytes]').to_i + event.get('[server][bytes]').to_i
                     event.set('[totDataBytes]', totBytes)
                     event.set('[network][bytes]', totBytes)
                     event.set('[network][packets]', event.get('[server][packets]').to_i + event.get('[client][packets]').to_i)"
          }

          # TODO: can we normalize suricata.flow.state with zeek.conn.conn_state_description somewhere?
        }


        #############################################################################################################################
        # tcp
        if ([suricata][tcp]) {
          ruby {
            id => "ruby_suricata_tcpflags"
            # TODO: we are just setting the count to 1 becaue we don't have a count really, is there something better?
            code => "
              event.set('[tcpflags][ack]', 1) if (event.get('[suricata][tcp][ack]') == 'true')
              event.set('[tcpflags][fin]', 1) if (event.get('[suricata][tcp][fin]') == 'true')
              event.set('[tcpflags][psh]', 1) if (event.get('[suricata][tcp][psh]') == 'true')
              event.set('[tcpflags][rst]', 1) if (event.get('[suricata][tcp][rst]') == 'true')
              event.set('[tcpflags][syn]', 1) if (event.get('[suricata][tcp][syn]') == 'true')
              event.set('[tcpflags][urg]', 1) if (event.get('[suricata][tcp][urg]') == 'true')
            "
          }
        }

        #############################################################################################################################
        # alert
        mutate {
                id => "mutate_rename_suricata_alert_severity"
                rename => { "[suricata][alert][severity]" => "[event][severity]" }
        }

        #############################################################################################################################
        # http
        mutate {
                id => "mutate_rename_suricata_http"
                rename => { "[suricata][http][protocol]" => "[http][version]"}
                rename => { "[suricata][http][status]" => "[http][response][status_code]"}
        }

        #############################################################################################################################
        # dhcp
        if ([suricata][dhcp][assigned_ip]) {
          mutate { id => "mutate_merge_suricata_dhcp_assigned_ip"
                   merge => { "[dhcp][host]" => "[suricata][dhcp][assigned_ip]" } }
        }

        if ([suricata][dhcp][client_mac]) {
          mutate {
            id => "mutate_add_fields_suricata_dhcp_source_mac"
            add_field =>  { "[source][mac]" => "%{[suricata][dhcp][client_mac]}" }
          }
          mutate { id => "mutate_merge_suricata_dhcp_client_mac"
                   merge => { "[dhcp][mac]" => "[suricata][dhcp][client_mac]" } }
        }

        if ([suricata][dhcp][id]) {
          mutate { id => "mutate_merge_suricata_dhcp_id"
                   merge => { "[dhcp][id]" => "[suricata][dhcp][id]" } }
        }

        if ([suricata][dhcp][dhcp_type]) {
          mutate { id => "mutate_merge_suricata_dhcp_type"
                   merge => { "[dhcp][type]" => "[suricata][dhcp][dhcp_type]" } }
        }

        #############################################################################################################################
        # dns
        mutate {
                id => "mutate_rename_suricata_dns"
                rename => { "[suricata][dns][id]" => "[dns][id]"}
                rename => { "[suricata][dns][type]" => "[dns][type]"}
                rename => { "[suricata][dns][rcode]" => "[dns][response_code]"}
        }

        #############################################################################################################################
        # smb

        if ([suricata][smb][filename]) {
          ruby {
            id => "ruby_suricata_smb_filename_dedoubleslash"
            path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
            script_params => {
              "source" => "[suricata][smb][filename]"
              "target" => "[suricata][smb][filename]"
            }
          }
        }

        #############################################################################################################################
        # tls
        mutate { id => "mutate_remove_field_suricata_ja3_strings"
                 remove_field => [ "[suricata][tls][ja3][string]",
                                   "[suricata][tls][ja3s][string]" ] }

        mutate {
                 id => "mutate_rename_suricata_tls"
                 rename => { "[suricata][tls][version]" => "[tls][version]"}
                 rename => { "[suricata][tls][ja3s][hash]" => "[tls][server][ja3s]"}
                 rename => { "[suricata][tls][ja3][hash]" => "[tls][client][ja3]"}
         }

         if ([tls][client][ja3] == "") {
                 mutate {
                         id => "mutate_remove_field_tls_client_ja3_suricata"
                         remove_field => [ "[tls][client][ja3]" ]
                 }
         }

         if ([tls][server][ja3s] == "") {
                 mutate {
                         id => "mutate_remove_field_tls_server_ja3s_suricata"
                         remove_field => [ "[tls][server][ja3s]" ]
                 }
         }

        #############################################################################################################################
        # tunnel
        if ([suricata][tunnel][proto]) {
          translate {
            id => "translate_suricata_tunnel_proto"
            source => "[suricata][tunnel][proto]"
            target => "[suricata][tunnel][proto]"
            dictionary_path => "/etc/ip_protocol_number_to_name.yaml"
          }
        }

        #############################################################################################################################
        # wrap-up

        # remove some fields we don't care about or aren't using the features associated with them
        mutate {
          id => "mutate_remove_field_suricata_useless"
          remove_field => [
            "[suricata][files][stored]",
            "[suricata][fileinfo][stored]",
            "[suricata][drop]",
            "[suricata][packet]",
            "[suricata][packet_info]",
            "[suricata][payload_printable]"
          ]
        }

        # create a repeatable fingerprint for document ID
        fingerprint {
          id => "fingerprint_suricata_event_hash_flow_id"
          source => [ "[event][provider]",
                      "[event][dataset]",
                      "[suricata][timestamp]",
                      "[network][community_id]",
                      "[suricata][flow_id]",
                      "[log][offset]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v1"
          method => "MURMUR3_128"
          base64encode => true
        }

    } else {
        drop { id => "drop_suricata_invalid_logs" }
    }

}