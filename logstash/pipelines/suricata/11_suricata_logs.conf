filter {

    # If message looks like json, try to parse it as such. Otherwise, drop it like it's hot.
    if [message] =~ /^{.*}$/ {

        # parse the json message from eve*.json
        json { id => "json_parse_suricata"
               source => "message"
               target => "suricata" }


        # drop fields we don't need
        mutate { id => "mutate_remove_field_suricata_message_and_stats"
                 remove_field => [ "[message]",
                                   "[suricata][stats]" ] }


        # generate a UUID for the document ID
        uuid {
          id => "uuid_suricata_random_uuid"
          target    => "[@metadata][uuid]"
          overwrite => true
        }

        if ([suricata][flow_id]) {
          # flow ID is sort of equivalent to zeek's conn UID

          # set suricata flow_id as "rootId"
          if (![rootId]) { mutate { id => "mutate_add_field_suricata_flow_id"
                                    add_field => { "[rootId]" => "%{[suricata][flow_id]}" } } }

          # ECS - suricata.flow_id -> event.id
          mutate { id => "mutate_add_field_ecs_suricata_event_id"
                   merge => { "[event][id]" => "[suricata][flow_id]" } }
        }

        # set document ID
        mutate { id => "mutate_add_field_suricata_without_flow_id_document_id"
                 add_field => { "[malcolmDocId]" => "%{[suricata][event_type]}-%{[suricata][flow_id]}:%{[@metadata][uuid]}" } }


        # take care of log timestamps in the formats all the different tools want them (phew!)
        # @timestamp - date type
        # suricata.timestamp - ISO8601-formatted string
        # suricata.flow.start - ISO8601-formatted string
        # suricata.flow.end - ISO8601-formatted string
        # timestamp - epoch millseconds
        # firstPacket - epoch millseconds
        # lastPacket - epoch millseconds
        # length - milliseconds
        # event.duration - epoch nanoseconds

        if (![suricata][timestamp]) {
          ruby {
            id => "ruby_suricata_timestamp_now"
            init => "require 'time'"
            code => "event.set('[suricata][timestamp]', Time.now.iso8601)"
          }
          mutate { id => "tag_suricata_empty_timestamp_set"
                   add_tag => [ "_missing_timestamp" ] }
        }
        date {
          id => "date_suricata_timestamp_match"
          match => [ "[suricata][timestamp]", "ISO8601" ]
          target => "[@timestamp]"
        }

        ruby {
          id => "ruby_suricata_timestamp_calc"
          init => "require 'time'; require 'date';"
          code => "
            timeStampMs = (1000*DateTime.parse(event.get('[suricata][timestamp]')).to_time.to_f).round(0)
            startTimeStr = event.get('[suricata][flow][start]')
            endTimeStr = event.get('[suricata][flow][end]')
            startTimeMs = startTimeStr.nil? ? timeStampMs : (1000*DateTime.parse(startTimeStr).to_time.to_f).round(0)
            endTimeMs = endTimeStr.nil? ? timeStampMs : (1000*DateTime.parse(endTimeStr).to_time.to_f).round(0)
            durationMs = (endTimeMs > startTimeMs) ? endTimeMs-startTimeMs : 0
            event.set('[timestamp]', timeStampMs)
            event.set('[firstPacket]', startTimeMs)
            event.set('[lastPacket]', endTimeMs)
            event.set('[length]', durationMs)
            event.set('[event][duration]', 1000000*durationMs)
          "
        }

        date {
          id => "date_suricata_timestamp_iso_match"
          match => [ "[suricata][timestamp]", "ISO8601" ]
          target => "[suricata][timestamp]"
        }
        if ([suricata][flow]) {
          date {
            id => "date_suricata_flow_start_iso_match"
            match => [ "[suricata][flow][start]", "ISO8601" ]
            target => "[suricata][flow][start]"
          }
          date {
            id => "date_suricata_flow_end_iso_match"
            match => [ "[suricata][flow][end]", "ISO8601" ]
            target => "[suricata][flow][end]"
          }
        }

        #Renaming the global fields of every Suricata event type
        mutate { id => "mutate_suricata_rename_global_fields"
                 rename => { "[suricata][app_proto]" => "network.protocol" }
                 rename => { "[suricata][community_id]" => "network.community_id" }
                 rename => { "[suricata][dest_ip]" => "destination.ip" }
                 rename => { "[suricata][dest_port]" => "destination.port" }
                 rename => { "[suricata][src_ip]" => "source.ip" }
                 rename => { "[suricata][src_port]" => "source.port" }
        }

        ###
        #
        # This section will be for renaming specific event type field names
        # that are able to be mapped to the Elastic Common Schema (ECS)
        #
        ###

        #Specific Alert renaming
        mutate {
                id => "mutate_rename_suricata_alert_severity"
                rename => { "[suricata][alert][severity]" => "[event][severity]" }
        }

        #Specific http renaming
        mutate {
                id => "mutate_rename_suricata_http"
                rename => { "[suricata][http][protocol]" => "[http][version]"}
                rename => { "[suricata][http][status]" => "[http][response][status_code]"}
        }

        #Specific dns renaming
        mutate {
                id => "mutate_rename_suricata_dns"
                rename => { "[suricata][dns][id]" => "[dns][id]"}
                rename => { "[suricata][dns][type]" => "[dns][type]"}
                rename => { "[suricata][dns][rcode]" => "[dns][response_code]"}
        }

        mutate { id => "mutate_remove_field_suricata_ja3_strings"
                 remove_field => [ "[suricata][tls][ja3][string]",
                                   "[suricata][tls][ja3s][string]" ] }

        #Specific tls renaming
        mutate {
                 id => "mutate_rename_suricata_tls"
                 rename => { "[suricata][tls][version]" => "[tls][version]"}
                 rename => { "[suricata][tls][ja3s][hash]" => "[tls][server][ja3s]"}
                 rename => { "[suricata][tls][ja3][hash]" => "[tls][client][ja3]"}
         }

         if ([tls][client][ja3] == "") {
                 mutate {
                         id => "mutate_remove_field_tls_client_ja3_suricata"
                         remove_field => [ "[tls][client][ja3]" ]
                 }
         }

         if ([tls][server][ja3s] == "") {
                 mutate {
                         id => "mutate_remove_field_tls_server_ja3s_suricata"
                         remove_field => [ "[tls][server][ja3s]" ]
                 }
         }

        #Specific fileinfo renaming
        mutate {
                id => "mutate_rename_suricata_fileinfo"
                rename => { "[suricata][fileinfo][size]" => "[file][size]"}
                rename => { "[suricata][fileinfo][sid]" => "[file][uid]"}
                rename => { "[suricata][fileinfo][filename]" => "[file][path]"}
        }

        #This is done in security onion, might be good to add, but not including it yet
        #Not in common schema, still think it would be helpful, needs to be added to Malcolm
        # if [event_type] == "alert" {
        #         if [alert][severity] == 1 {
        #                 mutate {
        #                         add_field => { "event.severity_name" => "High" }
        #                 }
        #         }
        #         if [alert][severity] == 2 {
        #                 mutate {
        #                         add_field => { "event.severity_name" => "Medium" }
        #                 }
        #         }
        #         if [alert][severity] == 3 {
        #                 mutate {
        #                         add_field => { "event.severity_name" => "Low" }
        #                 }
        #         }
        # }

        if (![event][provider]) { mutate { id => "mutate_add_field_event_provider_suricata"
                                           add_field => { "[event][provider]" => "suricata" } } }

        # rename suricata event type (eg., alert, dns, etc.) to event.dataset
        mutate { id => "mutate_rename_suricata_event_type"
                 rename => { "[suricata][event_type]" => "[event][dataset]" } }

    } else {
        drop { id => "drop_suricata_invalid_logs" }
    }

}