filter {

  # TODO:
  # suricata.alert.category
  # suricata.alert.metadata.former_category
  # suricata.alert.signature - ET SCAN Zmap User-Agent (Inbound)
  # suricata.alert.signature_id - 2029054

  # IP addresses ######################################################################################################
  # ECS - various -> related.ip (all IP-type fields get rolled up into related.ip)

  if ([suricata][dhcp][assigned_ip]) {          mutate { id => "mutate_merge_field_related_ip_suricata_dhcp_assigned_ip"
                                                         merge => { "[related][ip]" => "[suricata][dhcp][assigned_ip]" } } }
  if ([suricata][snmp][trap_address]) {         mutate { id => "mutate_merge_normalize_suricata_snmp_trap_address"
                                                         merge => { "[related][ip]" => "[suricata][snmp][trap_address]" } } }
  if ([suricata][tunnel][src_ip]) {             mutate { id => "mutate_merge_field_related_ip_suricata_sunnel_src_ip"
                                                         merge => { "[related][ip]" => "[suricata][tunnel][src_ip]" } } }
  if ([suricata][tunnel][dest_ip]) {            mutate { id => "mutate_merge_field_related_ip_suricata_sunnel_dest_ip"
                                                         merge => { "[related][ip]" => "[suricata][tunnel][dest_ip]" } } }

  # Action ############################################################################################################
  # collect all actions/operations/commands under the parent [event][action] array

  if ([suricata][dcerpc][request])               { mutate { id => "mutate_merge_normalize_suricata_dcerpc_request"
                                                            merge => { "[event][action]" => "[suricata][dcerpc][request]" } } }

  if ([suricata][dhcp][dhcp_type])               { mutate { id => "mutate_merge_normalize_suricata_dhcp_type"
                                                            merge => { "[event][action]" => "[suricata][dhcp][dhcp_type]" } } }

  if ([suricata][dhcp][type])                    { mutate { id => "mutate_merge_normalize_suricata_dhcp_dhcp_type"
                                                            merge => { "[event][action]" => "[suricata][dhcp][type]" } } }

  if ([suricata][ftp][command])                  { mutate { id => "mutate_merge_normalize_suricata_ftp_command"
                                                            merge => { "[event][action]" => "[suricata][ftp][command]" } } }

  if ([suricata][ikev2][payload])                { mutate { id => "mutate_merge_normalize_suricata_ikev2_payload"
                                                            merge => { "[event][action]" => "[suricata][ikev2][payload]" } } }

  if ([suricata][krb5][msg_type])                { mutate { id => "mutate_merge_field_event_action_suricata_krb5_msg_type"
                                                            merge => { "[event][action]" => "[suricata][krb5][msg_type]" } } }

  if ([suricata][sip][method])                   { mutate { id => "mutate_merge_normalize_suricata_sip_method"
                                                            merge => { "[event][action]" => "[suricata][sip][method]" } } }

  if ([suricata][snmp][pdu_type])                { mutate { id => "mutate_merge_normalize_suricata_snmp_pdu_type"
                                                            merge => { "[event][action]" => "[suricata][snmp][pdu_type]" } } }

  if ([suricata][snmp][trap_type])               { mutate { id => "mutate_merge_normalize_suricata_snmp_trap_type"
                                                            merge => { "[event][action]" => "[suricata][snmp][trap_type]" } } }

  if ([suricata][tftp][packet])                  { mutate { id => "mutate_merge_normalize_suricata_tftp_packet"
                                                            merge => { "[event][action]" => "[suricata][tftp][packet]" } } }

  # Result ############################################################################################################
  # collect all result/status/response/errors under the parent [event][result] array

  if ([suricata][anomaly][event]) {             mutate { id => "mutate_merge_field_event_result_suricata_anomaly_event"
                                                         merge => { "[event][result]" => "[suricata][anomaly][event]" } } }


  if ([dhcp][type]) {
    if ("ack" in [dhcp][type]) {
      mutate { id => "mutate_add_field_suricata_dhcp_ack_result"
               add_field => { "[@metadata][suricata_dhcp_result]" => "Success" } }
    } else if ("nak" in [dhcp][type]) {
      mutate { id => "mutate_add_field_suricata_dhcp_nak_result"
               add_field => { "[@metadata][suricata_dhcp_result]" => "Failure" } }
    }
    if ([@metadata][suricata_dhcp_result]) {
      mutate { id => "mutate_merge_suricata_dhcp_result"
               merge => { "[event][result]" => "[@metadata][suricata_dhcp_result]" } }
    }
  }

  if ([suricata][ftp][reply_code]) {
    # normalized version of reply code (reply_msg is too unpredictable)
    translate {
      id => "translate_suricata_ftp_completion_code"
      source => "[suricata][ftp][completion_code]"
      target => "[@metadata][suricata_ftp_mapped_result]"
      dictionary_path => "/etc/ftp_result_codes.yaml"
    }
    if ([@metadata][suricata_ftp_mapped_result]) {
      mutate { id => "mutate_merge_suricata_ftp_mapped_result"
               merge => { "[event][result]" => "[@metadata][suricata_ftp_mapped_result]" } }
    } else if ([suricata][ftp][reply]) {
      mutate { id => "mutate_merge_suricata_ftp_reply_result"
               merge => { "[event][result]" => "[suricata][ftp][reply_msg]" } }
    } else {
      mutate { id => "mutate_merge_suricata_ftp_completion_code_result"
               merge => { "[event][result]" => "[suricata][ftp][completion_code]" } }
    }
  }

  if ([suricata][sip][code]) {
    # normalized version of sip reply code (response_line may be unpredictable)
    translate {
      id => "translate_suricata_sip_reply_code"
      source => "[suricata][sip][code]"
      target => "[@metadata][suricata_sip_mapped_result]"
      dictionary_path => "/etc/sip_result_codes.yaml"
    }
    if ([@metadata][suricata_sip_mapped_result]) {
      mutate { id => "mutate_merge_suricata_sip_mapped_result"
               merge => { "[event][result]" => "[@metadata][suricata_sip_mapped_result]" } }
    } else if ([suricata][sip][reason]) {
      mutate { id => "mutate_merge_suricata_sip_reason_result"
               merge => { "[event][result]" => "[suricata][sip][reason]" } }
    } else if ([suricata][sip][status_msg]) {
      mutate { id => "mutate_merge_suricata_sip_response_line_result"
               merge => { "[event][result]" => "[suricata][sip][response_line]" } }
    } else {
      mutate { id => "mutate_merge_suricata_sip_code_result"
               merge => { "[event][result]" => "[suricata][sip][code]" } }
    }
  }

  if ([suricata][krb5][error_code]) {             mutate { id => "mutate_merge_field_event_result_suricata_krb5_error_code"
                                                           merge => { "[event][result]" => "[suricata][krb5][error_code]" } } }

  if ([suricata][snmp][error]) {                  mutate { id => "mutate_merge_normalize_suricata_snmp_error"
                                                            merge => { "[event][result]" => "[suricata][snmp][error]" } } }

  # Protocol/service version ##########################################################################################
  # collect protocol version under the parent network.protocol_version array

  if ([suricata][dcerpc][interfaces][version])          { mutate { id => "mutate_merge_normalize_suricata_dcerpc_interfaces_version"
                                                                   merge => { "[network][protocol_version]" => "[suricata][dcerpc][interfaces][version]" } } }

  if ([suricata][ikev2]) {
    ruby {
      id => "ruby_suricata_ikev2_version"
      code => "
        versions = Array.new unless (versions = event.get('[network][protocol_version]'))
        versions << [event.get('[suricata][ikev2][version_major]'),
                     event.get('[suricata][ikev2][version_minor]')].compact.join('.')
        event.set('[network][protocol_version]', versions.uniq) unless versions.nil? or (versions.length == 0)"
    }
  }

  if ([suricata][sip][version]) {
    mutate { id => "mutate_gsub_suricata_sip_version"
             gsub => [ "[suricata][sip][version]", "^.*/", "" ] }
    mutate { id => "mutate_merge_normalize_suricata_sip_version"
             merge => { "[network][protocol_version]" => "[suricata][sip][version]" } }
  }

  if ([suricata][snmp][version])                { mutate { id => "mutate_merge_normalize_suricata_snmp_version"
                                                           merge => { "[network][protocol_version]" => "[suricata][snmp][version]" } } }

  # URLs/URIs #########################################################################################################
  # ECS - various -> url.original

  if ([suricata][sip][uri]) {        mutate { id => "mutate_merge_field_suricata_sip_uri_url_original"
                                              merge => { "[url][original]" => "[suricata][sip][uri]" } } }

  # Hosts and domains #################################################################################################
  # ECS - various -> related.hosts (a lot of these are actually done in the enrichment pipeline)

  if ([suricata][smtp][helo]) {      mutate { id => "mutate_merge_field_suricata_smtp_helo_related_hosts"
                                              merge => { "[related][hosts]" => "[suricata][smtp][helo]" } } }

  if ([suricata][tls][sni]) {        mutate { id => "mutate_merge_field_suricata_tls_sni_related_hosts"
                                              merge => { "[related][hosts]" => "[suricata][tls][sni]" } } }

  # Username #########################################################################################################
  # ECS - various -> related.user

  if ([suricata][snmp][usm]) and ([suricata][snmp][usm] != '') {
    mutate { id => "mutate_merge_field_suricata_snmp_usm"
             merge => { "[related][user]" => "[suricata][snmp][usm]" } }
  }

  # Filenames #########################################################################################################
  # collect all filenames under the parent [file][path] array
  # ECS file.directory, file.name, file.path (https://www.elastic.co/guide/en/ecs/current/ecs-file.html)
  # - file.directory - directory where the file is located, including the drive letter when appropriate
  # - file.name - name of the file including the extension, without the directory
  # - file.path - full path to the file, including the file name, including the drive letter when appropriate
  # In the enrichment pipeline during normalization these fields will be used to construct each other.

  if ([suricata][tftp][file])             { mutate { id => "mutate_merge_normalize_suricata_tftp_file"
                                                     merge => { "[file][path]" => "[suricata][tftp][file]" } } }
  if ([suricata][smb][filename])          { mutate { id => "mutate_merge_normalize_suricata_smb_filename"
                                                     merge => { "[file][path]" => "[suricata][smb][filename]" } } }
  if ([suricata][fileinfo][filename])     { mutate { id => "mutate_merge_normalize_suricata_fileinfo_filename"
                                                     merge => { "[file][path]" => "[suricata][fileinfo][filename]" } } }
  if ([suricata][fileinfo][size]) and ([suricata][fileinfo][size] > 0) {
    mutate { id => "mutate_merge_normalize_suricata_fileinfo_size"
             merge => { "[file][size]" => "[suricata][fileinfo][size]" } }
  }

  if ([suricata][files]) {
    ruby {
        id => "ruby_suricata_files"
        code => "
            filePath = Array.new unless (filePath = event.get('[file][path]'))
            fileSize = Array.new unless (fileSize = event.get('[file][size]'))
            Array(event.get('[suricata][files]')).each { |val|
              fname = val&.fetch('filename', nil)
              fsize = val&.fetch('size', nil)
              fstate = val&.fetch('state', nil)
              filePath << fname unless fname.nil?
              fileSize << fsize unless fsize.nil?
            }
            event.set('[file][path]', filePath.uniq) unless filePath.nil? or (filePath.length == 0)
            event.set('[file][size]', fileSize.uniq) unless fileSize.nil? or (fileSize.length == 0)
        "
    }
  }

  # File/MIME types ###################################################################################################
  # ECS -> various -> file.mime_type
  # collect all file/MIME types under the parent [file][mime_type] array

  if ([suricata][fileinfo][magic]) {        mutate { id => "mutate_merge_normalize_suricata_fileinfo_mime_type"
                                                     merge => { "[file][mime_type]" => "[suricata][fileinfo][magic]" } } }

  # File/file source #####################################################################################################
  # ECS -> various -> file.source
  # collect file source under file.source
  if ([file]) and ([network][protocol])      { mutate { id => "mutate_suricata_merge_file_source"
                                                        merge => { "[file][source]" => "[network][protocol]" } } }

  # Hashes ############################################################################################################
  # ECS - various -> related.hash (accumulate all hash/fingerprint fields into related.hash)
  if ([suricata][fileinfo][md5]) {          mutate { id => "mutate_merge_field_related_hash_fileinfo_md5"
                                                     merge => { "[related][hash]" => "[suricata][fileinfo][md5]" } } }
  if ([suricata][fileinfo][sha1]) {         mutate { id => "mutate_merge_field_related_hash_fileinfo_sha1"
                                                     merge => { "[related][hash]" => "[suricata][fileinfo][sha1]" } } }
  if ([suricata][fileinfo][sha256]) {       mutate { id => "mutate_merge_field_related_hash_fileinfo_sha256"
                                                     merge => { "[related][hash]" => "[suricata][fileinfo][sha256]" } } }


}